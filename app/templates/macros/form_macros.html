{# WTForms macros heavily inspired by Flask-Bootstrap.
 # Consult their docs if you are confused about anything here:
 # http://pythonhosted.org/Flask-Bootstrap/macros.html?highlight=quick_form#quick_form #}

{# Render a flask.ext.wtforms.Form object.
   Parameters:
        form          – The form to output.
        method        – <form> method attribute (default 'POST')
        extra_classes – The classes to add to the <form>.
        enctype       – <form> enctype attribute. If None, will automatically be set to
                        multipart/form-data if a FileField is present in the form. 

   Render Form renders a form object. It calls the begin form macro. Initially
   a 'flashes' variable is set with 'error', 'warning', 'info', 'success' which
   have values gathered from the get_flashed_messages method from flask. Note
   that all flashes are stored in SESSIOn with a category type. For most of our
   purposes, we only have form-error and form-success as our flash types (the
   second parameter in the flash function call seen in the views. 

   Then the begin_form macro is called and for each form field in the provided
   form render_form_field macro is called with the field. 
   All hidden fields (i.e. the CSRF field) and all submit fields is not rendered
   at this fime in render_form_field. In the render_form_field
   method, render_form_input is called for each input in the form field.

   After that, the form_message macro is called with each of the flash types.

   Lastly, the submit field is rendered. And the form is closed with the end_form
   macro
#}
{% macro render_form(form, method='POST', extra_classes='', enctype=None) %}
    {% set flashes = {
        'error':   get_flashed_messages(category_filter=['form-error']),
        'warning': get_flashed_messages(category_filter=['form-check-email']),
        'info':    get_flashed_messages(category_filter=['form-info']),
        'success': get_flashed_messages(category_filter=['form-success'])
    } %}

    {{ begin_form(form, flashes, method=method, extra_classes=extra_classes, enctype=enctype) }}
        {% for field in form if not (is_hidden_field(field) or field.type == 'SubmitField') %}
            {{ render_form_field(field) }}
        {% endfor %}

        {{ form_message(flashes['error'], header='Something went wrong.', class='error') }}
        {{ form_message(flashes['warning'], header='Check your email.', class='warning') }}
        {{ form_message(flashes['info'], header='Information', class='info') }}
        {{ form_message(flashes['success'], header='Success!', class='success') }}

        {% for field in form | selectattr('type', 'equalto', 'SubmitField') %}
            {{ render_form_field(field) }}
        {% endfor %}
    {{ end_form(form) }}
{% endmacro %}

{# Set up the form, including hidden fields and error states.
   begin_form is called from render_form. First a check is performed to check
   if there exists a field within the form with type equal to FileField. This 
   check is performed via filter ("|") in Jinja. This initial check produces a
   filtered object, the 'list' filter creates a iterable list which we can then
   check the length of with 'length > 0'. So if this check passes, then the enctype
   must be set to multipart/form-data to accomodate a file upload. Otherwise, there
   is no enctype.

   Then the form tag is created with a method default of POST, enctype decided by the
   check explained above. If there are errors (by field specific validator errors or 
   if the flashes.error, flashes.warning, flashes.info, flashes.success is not None, 
   then that class is added to the overall class of the form (along with any specified
   extra_classes, default = ''). 

   Lastly the hidden_tags are rendered. WTForms includes in this method the rendering of
   the hidden CSRF field. We don't have to worry about that. 

   Example output:
   <form action="" method="POST" enctype="multipart/form-data" class="ui form">
      <div style="display:none;">
        <input id="csrf_token" name="csrf_token" type="hidden" 
               value="SOME_CSRF_TOKEN_HERE"> 
#}
{% macro begin_form(form, flashes, method='POST', extra_classes='', enctype=None) %}
    {# Set proper enctype #}
    {% if enctype is none and (form | selectattr('type', 'equalto', 'FileField') | list | length > 0) %}
        {% set enctype = 'multipart/form-data' %}
    {% else %}
        {% set enctype = '' %}
    {% endif %}

    <form action="" method="{{ method }}" enctype="{{ enctype }}" class="ui form {{ extra_classes }}
        {% if form.errors or flashes['error'] %} error
        {% elif flashes['warning'] %} warning
        {% elif flashes['info'] %} info
        {% elif flashes['success'] %} success
        {% endif %}">
    {{ form.hidden_tag() }}
{% endmacro %}

{# Mirrors begin_form #}
{% macro end_form(form) %}
    </form>
{% endmacro %}

{# Render a message for the form. This is called from the render_form macro.
   Recall the get_flashed_messages method. It will get the flash message from
   the SESSION object with a given cateogory_filter. Within the render_form 
   macro, the flashes variable is set with attributes 'errors', 'success',
   'info', and 'warning'. The messages parameter for form_message contains the
   flash messages for the respective attribute specified in flashes['some_attr'].

   The form_message macro is called after all form fields have been rendered,
   except for the Submit field. A div is created with class= 'ui CLASS message'
   class being either error, success, info, or warning. This div is only created
   if there are messages for a given flashes type! For each of the messages in
   the flashes type, the message is filtered to only contain escaped HTML chars
   and appended within the div ul as a list element.

   Example Output:
   <div class="ui error message">
      <div class="header">Something went wrong.</div>
      <ul class="list">
        <li>Invalid email or password.</li>
      </ul>
   </div>
#}
{% macro form_message(messages, header=none, class='') %}
    {% if messages %}
        <div class="ui {{ class }} message">
            {% if header is not none %}
                <div class="header">{{ header }}</div>
            {% endif %}
            {% if messages %}
                <ul class="list">
                    {% for message in messages %}
                        <li>{{ message | safe }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
    {% endif %}
{% endmacro %}

{# Render a field for the form. This is rather self explanatory. If the field is 
   a radio field (RadioField WTForms object) extra_classes has an added class of
   'grouped fields' since all the options of a Radio Field must be styled in this
   way to display together.
   If there is a validation error on the form field, a error class is added to the
   field div (to make the field colored red). Then the render_form_input macro is 
   called with field object itself as a parameter. Any validation errors are then
   added with a sub-dev with content field.errors (we only show the first validation
   error for the given error for simplicity) and filter for HTML safe chars.
#}
{% macro render_form_field(field, extra_classes='') %}
    {% if field.type == 'RadioField' %}
        {% set extra_classes = extra_classes + ' grouped fields' %}
    {% endif %}
    <div class="field {% if field.errors %}error{% endif %} {{ extra_classes }}">
        {{ render_form_input(field) }}
        {% if field.errors %}
            <div class="ui red pointing label">
                {{ field.errors[0] | safe }}
            </div>
        {% endif %}
    </div>
{% endmacro %}

{# This code is rather self explanatory. The {{ field }} object contains
   most of the html code used to render the form field itself. The label
   is used only for (well) labeling the form field itself. The value of 
   the field is handled on wtforms end and any modifications for that 
   behavior should be done in forms.py for each respective view.
   Note the FormField type indicates a sub-form within the form. This is
   useful for doing something like inputting a phone number with 3
   form fields. Or you could create your own field type within forms.py
#}
{% macro render_form_input(field) %}
    {% if field.widget.input_type == 'checkbox' %}
        <div class="ui checkbox">
            {{ field }}
            {{ field.label }}
        </div>
    {% elif field.type == 'RadioField' %}
        {% for item in field %}
            <div class="ui radio checkbox">
                {{ field }}
                {{ field.label }}
            </div>
        {% endfor %}
    {% elif field.type == 'SubmitField' %}
        {{ field(class='ui button') }}
    {% elif field.type == 'FormField' %}
        {{ render_form(field) }}
    {% else %}
        {{ field.label }}
        {{ field(placeholder=field.label.text) }}
    {% endif %}
{% endmacro %}
